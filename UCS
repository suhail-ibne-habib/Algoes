import heapq

def ucs_shortest_path(graph, start, goal):
    if start not in graph or goal not in graph:
        return None, None 
    
    pq = [ ( 0, start, [start]) ] 
    visited = set()

    while pq:
        cost, node, path = heapq.heappop(pq)

        if node == goal:
            return path, cost 
        
        if node in visited:
            continue

        visited.add(node)

        for neighbor, edge_cost in graph.get(node, []):
            if neighbor not in visited:
                heapq.heappush(
                    pq, 
                    ( cost + edge_cost, neighbor, path + [neighbor] )
                )
            
    return None, None 

graph = {
    'A': [ ('B', 5), ('C', 3) ],
    'B': [ ('A', 5), ('D', 2), ('E', 4) ],
    'C': [ ('A', 3), ('F', 8) ],
    'D': [ ('B', 2) ],
    'E': [ ('B', 4), ('F', 1) ],
    'F': [ ('C', 8), ('E', 1) ]
}

start = 'A'
goal = 'F'

path, cost = ucs_shortest_path(graph, start, goal)

if path:
    print(f"The shortest path from {start} to {goal}: {'->'.join(path)}")
    print(f"The cost: {cost}")
else:
    print("No Path found!")
