from collections import deque

def dfs_path_cost(graph, start, goal):
    if start not in graph or goal not in graph:
        return None, None 
    
    queue = deque( [ ( start, [start], 0 ) ] )
    visited = {start}

    while queue:
        node, path, cost = queue.pop()

        if node == goal:
            return path, cost 
        
        for neighbor, edge_cost in graph.get( node, [] ):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append( ( neighbor, path + [neighbor], edge_cost + cost ) )
        
    return None, None

graph = {
    'A': [ ('B', 5), ('C', 3) ],
    'B': [ ('A', 5), ('D', 2), ('E', 4) ],
    'C': [ ('A', 3), ('F', 8) ],
    'D': [ ('B', 2) ],
    'E': [ ('B', 4), ('F', 1) ],
    'F': [ ('C', 8), ('E', 1) ]
}

start = 'A'
goal = 'F'

path, cost = dfs_path_cost(graph, start, goal)

if path and cost:
    print(f"Path from {start} to {goal}: {'->'.join(path)}")
    print(f"Path cost: {cost}")
else:
    print(f"No path found!")
